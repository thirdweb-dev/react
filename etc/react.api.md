## API Report File for "@thirdweb-dev/react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbiFunction } from '@thirdweb-dev/sdk/dist/src/schema/contracts/custom';
import { AuctionListing } from '@thirdweb-dev/sdk';
import { BaseProvider } from '@ethersproject/providers';
import { BigNumber } from 'ethers';
import type { BigNumberish } from 'ethers';
import { Chain } from '@wagmi/core';
import { ChainId } from '@thirdweb-dev/sdk';
import { Connector } from '@wagmi/core';
import { ConnectResult } from '@wagmi/core';
import { ContractForContractType } from '@thirdweb-dev/sdk';
import { ContractType } from '@thirdweb-dev/sdk';
import { defaultChains } from '@wagmi/core';
import { defaultL2Chains } from '@wagmi/core';
import { DirectListing } from '@thirdweb-dev/sdk';
import { Edition } from '@thirdweb-dev/sdk';
import { EditionDrop } from '@thirdweb-dev/sdk';
import { EditionMetadataOrUri } from '@thirdweb-dev/sdk/dist/src/schema';
import type { Erc1155 } from '@thirdweb-dev/sdk';
import type { Erc20 } from '@thirdweb-dev/sdk';
import { Erc721 } from '@thirdweb-dev/sdk';
import { FetchStatus } from 'react-query';
import { IpfsStorage } from '@thirdweb-dev/sdk';
import { IStorage } from '@thirdweb-dev/sdk';
import { Json } from '@thirdweb-dev/sdk';
import { Marketplace } from '@thirdweb-dev/sdk';
import type { MarketplaceFilter } from '@thirdweb-dev/sdk';
import { NetworkOrSignerOrProvider } from '@thirdweb-dev/sdk';
import type { NewAuctionListing } from '@thirdweb-dev/sdk';
import type { NewDirectListing } from '@thirdweb-dev/sdk';
import { NFTCollection } from '@thirdweb-dev/sdk';
import { NFTDrop } from '@thirdweb-dev/sdk';
import { NFTMetadata } from '@thirdweb-dev/sdk';
import { NFTMetadataOrUri } from '@thirdweb-dev/sdk/dist/src/schema';
import { NFTMetadataOwner } from '@thirdweb-dev/sdk';
import { Pack } from '@thirdweb-dev/sdk';
import { PropsWithChildren } from 'react';
import { PublishedMetadata } from '@thirdweb-dev/sdk/dist/src/schema/contracts/custom';
import { QueryAllParams } from '@thirdweb-dev/sdk';
import { QueryClient } from 'react-query';
import { QueryObserverResult } from 'react-query';
import { default as React_2 } from 'react';
import { RefetchOptions } from 'react-query';
import { RefetchQueryFilters } from 'react-query';
import { SDKOptions } from '@thirdweb-dev/sdk';
import { Signer } from 'ethers';
import { SmartContract } from '@thirdweb-dev/sdk';
import { Split } from '@thirdweb-dev/sdk';
import { SUPPORTED_CHAIN_ID } from '@thirdweb-dev/sdk';
import { SwitchNetworkArgs } from '@wagmi/core';
import { ThirdwebSDK } from '@thirdweb-dev/sdk';
import { Token } from '@thirdweb-dev/sdk';
import { TokenDrop } from '@thirdweb-dev/sdk';
import { TransactionReceipt } from '@ethersproject/abstract-provider';
import { TransactionResultWithId } from '@thirdweb-dev/sdk';
import { useAccount } from './hooks';
import { UseMutationResult } from 'react-query';
import { UseQueryResult } from 'react-query';
import { useSigner } from './hooks';
import { ValidContractInstance } from '@thirdweb-dev/sdk';
import { Vote } from '@thirdweb-dev/sdk';

export { ChainId }

export { defaultChains }

export { defaultL2Chains }

// Warning: (ae-internal-missing-underscore) The name "detectErc721Instance" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function detectErc721Instance(contract: RequiredParam<ValidContractInstance | SmartContract>): Erc721<any> | undefined;

// @beta
export type EditionMintParams = {
    to: WalletAddress;
} & EditionMetadataOrUri;

export { IpfsStorage }

// @public
export const MediaRenderer: React_2.ForwardRefExoticComponent<MediaRendererProps & {
    children?: React_2.ReactNode;
} & React_2.RefAttributes<HTMLMediaElement>>;

// @public
export interface MediaRendererProps extends SharedMediaProps {
    alt?: string;
    poster?: string;
    src?: string;
}

// @public (undocumented)
export interface MediaType {
    // (undocumented)
    mimeType?: string;
    // (undocumented)
    url?: string;
}

// @beta
export type NFTMintParams = {
    to: WalletAddress;
    metadata: NFTMetadataOrUri;
};

// @beta
export type RequiredParam<T> = T | undefined;

// @public (undocumented)
export interface SharedMediaProps {
    // (undocumented)
    className?: string;
    controls?: HTMLVideoElement["controls"];
    // (undocumented)
    height?: HTMLIFrameElement["height"];
    requireInteraction?: boolean;
    // (undocumented)
    style?: React_2.CSSProperties;
    // (undocumented)
    width?: HTMLIFrameElement["width"];
}

// @public
export const ThirdwebNftMedia: React_2.ForwardRefExoticComponent<ThirdwebNftMediaProps & React_2.RefAttributes<HTMLMediaElement>>;

// @public
export interface ThirdwebNftMediaProps extends SharedMediaProps {
    metadata: NFTMetadata;
}

// Warning: (ae-forgotten-export) The symbol "ThirdwebProviderProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ThirdwebProvider: React_2.FC<PropsWithChildren<ThirdwebProviderProps>>;

// @beta
export const ThirdwebSDKProvider: React_2.FC<React_2.PropsWithChildren<ThirdwebSDKProviderProps>>;

// @public (undocumented)
export interface ThirdwebSDKProviderProps {
    // Warning: (ae-incompatible-release-tags) The symbol "desiredChainId" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
    //
    // (undocumented)
    desiredChainId: RequiredParam<ChainId>;
    // (undocumented)
    provider: NetworkOrSignerOrProvider;
    // (undocumented)
    sdkOptions?: SDKOptions;
    // (undocumented)
    signer?: Signer;
    // (undocumented)
    storageInterface?: IStorage;
}

// @beta
export type TokenMintParams = {
    to: WalletAddress;
    amount: string | number;
};

export { useAccount }

// Warning: (ae-internal-missing-underscore) The name "useActiveChainId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useActiveChainId(): SUPPORTED_CHAIN_ID | undefined;

// @beta
export function useActiveListings(contract: RequiredParam<Marketplace>, filter?: MarketplaceFilter): UseQueryResult<(AuctionListing | DirectListing)[], unknown>;

// @public
export function useAddress(): string | undefined;

// @beta
export function useAllListings(contract: RequiredParam<Marketplace>, filter?: MarketplaceFilter): UseQueryResult<(AuctionListing | DirectListing)[], unknown>;

// Warning: (ae-internal-missing-underscore) The name "useBuiltinContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useBuiltinContract<TContractType extends ContractType>(contractType?: TContractType, contractAddress?: string): ContractForContractType<TContractType> | undefined;

// @public
export function useChainId(): number | undefined;

// @beta
export function useClaimedNFTs(contract: RequiredParam<NFTDrop>, queryParams?: QueryAllParams): UseQueryResult<NFTMetadataOwner[], unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useClaimedNftSupply" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
//
// @public (undocumented)
export function useClaimedNftSupply(contract: RequiredParam<NFTDrop>): UseQueryResult<BigNumber, unknown>;

// @public
export function useCoinbaseWallet(): () => Promise<ConnectResult<BaseProvider>>;

// Warning: (ae-internal-missing-underscore) The name "useConnect" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function useConnect(): {
    readonly activeConnector: Connector<any, any> | undefined;
    readonly connect: (connector_?: Connector<any, any> | undefined) => void;
    readonly connectAsync: (connector_?: Connector<any, any> | undefined) => Promise<ConnectResult<BaseProvider>>;
    readonly connectors: Connector<any, any>[];
    readonly data: ConnectResult<BaseProvider> | undefined;
    readonly error: Error | null;
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    readonly isDisconnected: boolean;
    readonly isError: boolean;
    readonly isIdle: boolean;
    readonly isReconnecting: boolean;
    readonly pendingConnector: Connector<any, any> | undefined;
    readonly reset: () => void;
    readonly status: "connecting" | "connected" | "reconnecting" | "disconnected" | "error" | "idle";
};

// @beta
export function useContract(contractAddress: RequiredParam<string>): {
    contract: undefined;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: undefined;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: undefined;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: undefined;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: Split | NFTDrop | NFTCollection | EditionDrop | Edition | TokenDrop | Token | Vote | Marketplace | Pack | SmartContract<any> | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: Split | NFTDrop | NFTCollection | EditionDrop | Edition | TokenDrop | Token | Vote | Marketplace | Pack | SmartContract<any> | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
    pubishMetadata: null;
    } | {
    contractType: "custom";
    pubishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
};

// Warning: (ae-internal-missing-underscore) The name "useContractFunctions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useContractFunctions(contractAddress: RequiredParam<string>): UseQueryResult<AbiFunction[] | null, unknown>;

// @beta
export function useContractMetadata(contractAddress: RequiredParam<string>): UseQueryResult<unknown, unknown>;

// @beta
export function useContractPublishMetadata(contractAddress: RequiredParam<string>): UseQueryResult<PublishedMetadata | undefined, unknown>;

// @beta
export function useContractType(contractAddress: RequiredParam<string>): UseQueryResult<"split" | "custom" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined, unknown>;

// @beta
export function useCreateAuctionListing(contract: RequiredParam<Marketplace>): UseMutationResult<TransactionResultWithId<never>, unknown, NewAuctionListing, unknown>;

// @beta
export function useCreateDirectListing(contract: RequiredParam<Marketplace>): UseMutationResult<TransactionResultWithId<never>, unknown, NewDirectListing, unknown>;

// Warning: (ae-internal-missing-underscore) The name "useDesiredChainId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useDesiredChainId(): number;

// @public
export function useDisconnect(options?: {
    reconnectAfterGnosis?: boolean;
}): () => Promise<void | ConnectResult<BaseProvider>>;

// @public
export function useEdition(contractAddress?: string): Edition | undefined;

// @public
export function useEditionDrop(contractAddress?: string): EditionDrop | undefined;

// @beta
export function useEditions(contract: RequiredParam<Erc1155>, queryParams?: QueryAllParams): UseQueryResult<    {
supply: BigNumber;
metadata: {
[x: string]: Json;
name?: string | undefined;
uri: string;
id: BigNumber;
description?: string | undefined;
image?: string | undefined;
external_url?: string | undefined;
animation_url?: string | undefined;
};
}[], unknown>;

// @beta
export function useEditionTotalCount(contract: RequiredParam<Erc1155>, tokenId: BigNumberish): UseQueryResult<BigNumber, unknown>;

// @public
export function useMarketplace(contractAddress?: string): Marketplace | undefined;

// @public
export function useMetamask(): () => Promise<ConnectResult<BaseProvider> | {
    error: Error;
}>;

// @beta
export function useMintEdition(contract: RequiredParam<Erc1155>): UseMutationResult<TransactionResultWithId<    {
supply: BigNumber;
metadata: {
[x: string]: Json;
name?: string | undefined;
uri: string;
id: BigNumber;
description?: string | undefined;
image?: string | undefined;
external_url?: string | undefined;
animation_url?: string | undefined;
};
}>, unknown, EditionMintParams, unknown>;

// @beta
export function useMintNFT(contract: RequiredParam<Erc721>): UseMutationResult<TransactionResultWithId<NFTMetadataOwner>, unknown, NFTMintParams, unknown>;

// @beta
export function useMintToken(contract: RequiredParam<Erc20>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, TokenMintParams, unknown>;

// @public
export function useNetwork(): {
    readonly activeChain: (Chain & {
        id: number;
        unsupported?: boolean | undefined;
    }) | undefined;
    readonly chains: Chain[];
    readonly data: Chain | undefined;
    readonly error: Error | null;
    readonly isError: boolean;
    readonly isIdle: boolean;
    readonly isLoading: boolean;
    readonly isSuccess: boolean;
    readonly pendingChainId: number | undefined;
    readonly reset: () => void;
    readonly status: "error" | "idle" | "loading" | "success";
    readonly switchNetwork: ((chainId_?: number | undefined) => void) | undefined;
    readonly switchNetworkAsync: ((chainId_?: number | undefined) => Promise<Chain>) | undefined;
    readonly variables: SwitchNetworkArgs | undefined;
};

// @public
export function useNetworkMismatch(): boolean;

// @public
export function useNFTCollection(contractAddress?: string): NFTCollection | undefined;

// @public
export function useNFTDrop(contractAddress?: string): NFTDrop | undefined;

// @beta
export function useNFTs(contract: RequiredParam<Erc721>, queryParams?: QueryAllParams): UseQueryResult<NFTMetadataOwner[], unknown>;

// @beta
export function useNFTSupply(contract: RequiredParam<Erc721>): UseQueryResult<BigNumber, unknown>;

// @public
export function usePack(contractAddress?: string): Pack | undefined;

// Warning: (ae-internal-missing-underscore) The name "useReadonlySDK" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useReadonlySDK(readonlyRpcUrl: string, sdkOptions: SDKOptions, storageInterface?: IStorage): ThirdwebSDK;

// @public (undocumented)
export function useResolvedMediaType(uri?: string): {
    url: string | undefined;
    mimeType: string | undefined;
};

// Warning: (ae-internal-missing-underscore) The name "useSDK" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useSDK(): ThirdwebSDK | undefined;

export { useSigner }

// @public
export function useSplit(contractAddress?: string): Split | undefined;

// @public
export function useToken(contractAddress?: string): Token | undefined;

// @beta
export function useTokenBalance(contract: RequiredParam<Erc20>, address: RequiredParam<string>): UseQueryResult<    {
symbol: string;
name: string;
decimals: number;
value: BigNumber;
displayValue: string;
}, unknown>;

// Warning: (ae-internal-missing-underscore) The name "useTokenDrop" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function useTokenDrop(contractAddress?: string): TokenDrop | undefined;

// @beta
export function useTokenSupply(contract: RequiredParam<Erc20>): UseQueryResult<    {
symbol: string;
name: string;
decimals: number;
value: BigNumber;
displayValue: string;
}, unknown>;

// @beta
export function useUnclaimedNFTs(contract: RequiredParam<NFTDrop>, queryParams?: QueryAllParams): UseQueryResult<    {
[x: string]: Json;
name?: string | undefined;
uri: string;
id: BigNumber;
description?: string | undefined;
image?: string | undefined;
external_url?: string | undefined;
animation_url?: string | undefined;
}[], unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useUnclaimedNftSupply" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
//
// @public (undocumented)
export function useUnclaimedNftSupply(contract: RequiredParam<NFTDrop>): UseQueryResult<BigNumber, unknown>;

// @public
export function useVote(contractAddress?: string): Vote | undefined;

// @public
export function useWalletConnect(): () => Promise<ConnectResult<BaseProvider>>;

// Warning: (ae-internal-missing-underscore) The name "useWalletLink" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function useWalletLink(): () => Promise<ConnectResult<BaseProvider>>;

// @beta
export type WalletAddress = string;

// (No @packageDocumentation comment for this package)

```
