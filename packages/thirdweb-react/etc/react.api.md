## API Report File for "@thirdweb-dev/react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbiFunction } from '@thirdweb-dev/sdk';
import type { AirdropInput } from '@thirdweb-dev/sdk';
import type { Amount } from '@thirdweb-dev/sdk';
import { AuctionListing } from '@thirdweb-dev/sdk';
import { BaseContract } from 'ethers';
import { BatchToReveal } from '@thirdweb-dev/sdk';
import { BigNumber } from 'ethers';
import { BigNumberish } from 'ethers';
import { CallOverrides } from 'ethers';
import { Chain } from './types';
import { ChainId } from '@thirdweb-dev/sdk';
import { ChainOrRpc } from '@thirdweb-dev/sdk';
import { ClaimConditionInput } from '@thirdweb-dev/sdk';
import { ClaimEligibility } from '@thirdweb-dev/sdk';
import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet';
import { Connector } from './connectors';
import { ConnectorData } from './connectors';
import type { ContractEvent } from '@thirdweb-dev/sdk';
import { ContractForContractType } from '@thirdweb-dev/sdk';
import { ContractType } from '@thirdweb-dev/sdk';
import { defaultChains } from './constants';
import { defaultL2Chains } from './constants';
import { DirectListing } from '@thirdweb-dev/sdk';
import { Edition } from '@thirdweb-dev/sdk';
import { EditionDrop } from '@thirdweb-dev/sdk';
import { Erc1155 } from '@thirdweb-dev/sdk';
import type { Erc1155Mintable } from '@thirdweb-dev/sdk';
import { Erc20 } from '@thirdweb-dev/sdk';
import type { Erc721 } from '@thirdweb-dev/sdk';
import type { Erc721Mintable } from '@thirdweb-dev/sdk';
import type { EventQueryFilter } from '@thirdweb-dev/sdk';
import { FetchStatus } from '@tanstack/react-query';
import { InjectedConnector } from 'wagmi/connectors/injected';
import type { IStorage } from '@thirdweb-dev/storage';
import { Json } from '@thirdweb-dev/sdk';
import { ListingType } from '@thirdweb-dev/sdk';
import { LoginOptions } from '@thirdweb-dev/sdk/dist/src/schema';
import { LoginOptions as LoginOptions_2 } from '@thirdweb-dev/sdk';
import { LoginWithMagicLinkConfiguration } from 'magic-sdk';
import type { MagicSDKAdditionalConfiguration } from 'magic-sdk';
import { Marketplace } from '@thirdweb-dev/sdk';
import type { MarketplaceFilter } from '@thirdweb-dev/sdk';
import { Multiwrap } from '@thirdweb-dev/sdk';
import type { NewAuctionListing } from '@thirdweb-dev/sdk';
import type { NewDirectListing } from '@thirdweb-dev/sdk';
import { NFTCollection } from '@thirdweb-dev/sdk';
import { NFTDrop } from '@thirdweb-dev/sdk';
import { NFTMetadata } from '@thirdweb-dev/sdk';
import { NFTMetadataInput } from '@thirdweb-dev/sdk';
import type { NFTMetadataInput as NFTMetadataInput_2 } from '@thirdweb-dev/sdk/dist/src/schema';
import type { NFTMetadataOrUri } from '@thirdweb-dev/sdk/dist/src/schema';
import { Offer } from '@thirdweb-dev/sdk';
import { Pack } from '@thirdweb-dev/sdk';
import type { Price } from '@thirdweb-dev/sdk';
import { PropsWithChildren } from 'react';
import { QueryAllParams } from '@thirdweb-dev/sdk';
import { QueryClient } from '@tanstack/react-query';
import { QueryObserverResult } from '@tanstack/react-query';
import { default as React_2 } from 'react';
import { RefetchOptions } from '@tanstack/react-query';
import { RefetchQueryFilters } from '@tanstack/react-query';
import type { Role } from '@thirdweb-dev/sdk';
import { SDKOptions } from '@thirdweb-dev/sdk';
import { SignatureDrop } from '@thirdweb-dev/sdk';
import { Signer } from 'ethers';
import { SignerOrProvider } from '@thirdweb-dev/sdk';
import { SmartContract } from '@thirdweb-dev/sdk';
import { Split } from '@thirdweb-dev/sdk';
import { SUPPORTED_CHAIN_ID } from '@thirdweb-dev/sdk';
import { ThirdwebSDK } from '@thirdweb-dev/sdk';
import { Token } from '@thirdweb-dev/sdk';
import { TokenDrop } from '@thirdweb-dev/sdk';
import { TransactionError } from '@thirdweb-dev/sdk';
import { TransactionReceipt } from '@ethersproject/abstract-provider';
import { TransactionResult } from '@thirdweb-dev/sdk';
import { TransactionResultWithId } from '@thirdweb-dev/sdk';
import { UploadProgressEvent } from '@thirdweb-dev/sdk';
import { useAccount } from './hooks';
import { UseMutationResult } from '@tanstack/react-query';
import { useProvider } from './hooks';
import { UseQueryResult } from '@tanstack/react-query';
import type { ValidContractInstance } from '@thirdweb-dev/sdk';
import { Vote } from '@thirdweb-dev/sdk';
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect';

// @beta
export type AirdropNFTParams = {
    tokenId: BigNumberish;
    addresses: AirdropInput;
};

// @beta
export type BurnNFTParams<TContract extends NFTContract> = TContract extends Erc1155 ? {
    tokenId: BigNumberish;
    amount: Amount;
} : {
    tokenId: BigNumberish;
};

// @public (undocumented)
export type BuyNowParams<TListingType = ListingType> = TListingType extends ListingType.Direct ? {
    id: BigNumberish;
    type: ListingType.Direct;
    buyAmount: BigNumberish;
    buyForWallet?: WalletAddress;
} : {
    id: BigNumberish;
    type: ListingType.Auction;
};

export { ChainId }

// Warning: (ae-forgotten-export) The symbol "SupportedChain" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// Warning: (ae-forgotten-export) The symbol "Chain" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// Warning: (ae-internal-missing-underscore) The name "ChainRpc" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ChainRpc<TSupportedChain extends SupportedChain> = Record<TSupportedChain extends Chain_2 ? TSupportedChain["id"] : TSupportedChain, string>;

// @beta
export type ClaimIneligibilityParameters = {
    walletAddress: WalletAddress;
    quantity: string | number;
};

// @beta
export type ClaimNFTParams<TContract extends DropContract> = TContract extends Erc1155 ? {
    to: WalletAddress;
    tokenId: BigNumberish;
    quantity: BigNumberish;
    checkERC20Allowance?: boolean;
} : {
    to: WalletAddress;
    quantity: BigNumberish;
    checkERC20Allowance?: boolean;
};

// @beta
export type ClaimNFTReturnType<TContract extends DropContract> = TContract extends Erc721 ? Awaited<ReturnType<TContract["claimTo"]>> : TContract extends Erc1155 ? Awaited<ReturnType<TContract["claimTo"]>> : never;

// @public (undocumented)
export type ClaimTokenParams = {
    to: WalletAddress;
    amount: Amount;
    checkERC20Allowance?: boolean;
};

// Warning: (ae-forgotten-export) The symbol "ConnectWalletProps" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
//
// @beta
export const ConnectWallet: React_2.FC<ConnectWalletProps>;

// @beta
export type ContractAddress = string;

// Warning: (ae-internal-missing-underscore) The name "ContractWithRoles" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ContractWithRoles = Exclude<ValidContractInstance, Vote | Split | Multiwrap> | SmartContract;

// @public
export interface DAppMetaData {
    description?: string;
    isDarkMode?: boolean;
    logoUrl?: string;
    name: string;
    url?: string;
}

export { defaultChains }

export { defaultL2Chains }

// @beta
export type DelayedRevealLazyMintInput = {
    placeholder: NFTMetadataInput_2;
    metadatas: NFTMetadataInput_2[];
    password: string;
};

// @beta
export type DropContract = NFTDrop | EditionDrop | SignatureDrop;

// Warning: (ae-internal-missing-underscore) The name "GnosisConnectorType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type GnosisConnectorType = "gnosis" | {
    name: "gnosis";
    options: GnosisConnectorArguments;
};

// Warning: (ae-internal-missing-underscore) The name "InjectedConnectorType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type InjectedConnectorType = "injected" | "metamask" | {
    name: "injected" | "metamask";
    options?: InjectedConnector["options"];
};

// @public (undocumented)
export interface LoginConfig {
    onError?: (error: string) => void;
    redirectTo?: string;
}

// Warning: (ae-internal-missing-underscore) The name "MagicConnectorType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type MagicConnectorType = "magic" | {
    name: "magic";
    options: Omit<MagicConnectorArguments, "network">;
};

// @public (undocumented)
export type MakeBidParams = {
    listingId: BigNumberish;
    bid: Price;
};

// @public
export const MediaRenderer: React_2.ForwardRefExoticComponent<MediaRendererProps & {
    children?: React_2.ReactNode;
} & React_2.RefAttributes<HTMLMediaElement>>;

// @public
export interface MediaRendererProps extends SharedMediaProps {
    alt?: string;
    poster?: string | null;
    src?: string | null;
}

// @public (undocumented)
export interface MediaType {
    // (undocumented)
    mimeType?: string;
    // (undocumented)
    url?: string;
}

// @beta
export type MintNFTParams<TContract extends NFTContract> = TContract extends Erc1155 ? {
    metadata: NFTMetadataOrUri;
    supply: BigNumberish;
    to: WalletAddress;
} : {
    metadata: NFTMetadataOrUri;
    to: WalletAddress;
};

// @beta
export type MintNFTReturnType<TContract> = TContract extends Erc721 ? Awaited<ReturnType<Erc721Mintable["to"]>> : TContract extends Erc1155 ? Awaited<ReturnType<Erc1155Mintable["to"]>> : never;

// @beta
export type MintNFTSupplyParams = {
    tokenId: BigNumberish;
    additionalSupply: Amount;
    to: WalletAddress;
};

// @beta
export type NFT<TContract extends NFTContract> = {
    metadata: NFTMetadata;
    owner: string;
    type: TContract extends Erc721 ? "ERC721" : "ERC1155";
    supply: TContract extends Erc721 ? 1 : number;
    [key: string]: unknown;
};

// @beta
export type NFTContract = Erc721 | Erc1155;

// @beta
export type RequiredParam<T> = T | undefined;

// @beta
export type RevealLazyMintInput = {
    batchId: BigNumberish;
    password: string;
};

// Warning: (ae-internal-missing-underscore) The name "RolesForContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type RolesForContract<TContract extends ContractWithRoles> = TContract extends SmartContract ? Role | (string & {}) : NonNullable<Exclude<TContract, SmartContract>["roles"]>["roles"][number];

// @beta
export type SetClaimConditionsParams = {
    phases: ClaimConditionInput[];
    reset?: boolean;
};

// @public (undocumented)
export interface SharedMediaProps {
    // (undocumented)
    className?: string;
    controls?: HTMLVideoElement["controls"];
    // (undocumented)
    height?: HTMLIFrameElement["height"];
    requireInteraction?: boolean;
    // (undocumented)
    style?: React_2.CSSProperties;
    // (undocumented)
    width?: HTMLIFrameElement["width"];
}

// @beta
export interface ThirdwebAuthConfig {
    authUrl: string;
    domain: string;
    loginRedirect?: string;
}

// @public (undocumented)
export interface ThirdwebAuthUser {
    // (undocumented)
    address: string;
}

// @beta (undocumented)
export const ThirdwebNftMedia: React_2.ForwardRefExoticComponent<ThirdwebNftMediaProps & React_2.RefAttributes<HTMLMediaElement>>;

// @public
export interface ThirdwebNftMediaProps extends SharedMediaProps {
    metadata: NFTMetadata;
}

// @public
export const ThirdwebProvider: <TSupportedChain extends SupportedChain = SupportedChain>({ sdkOptions, chainRpc, supportedChains, walletConnectors, dAppMeta, desiredChainId, authConfig, storageInterface, queryClient, autoConnect, children, }: React_2.PropsWithChildren<ThirdwebProviderProps<TSupportedChain>>) => JSX.Element;

// @public
export interface ThirdwebProviderProps<TSupportedChain extends SupportedChain = SupportedChain> {
    // @beta
    authConfig?: ThirdwebAuthConfig;
    autoConnect?: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "chainRpc" is marked as @public, but its signature references "ChainRpc" which is marked as @internal
    chainRpc?: Partial<ChainRpc<TSupportedChain>>;
    dAppMeta?: DAppMetaData;
    desiredChainId: TSupportedChain extends Chain_2 ? TSupportedChain["id"] : TSupportedChain | undefined;
    // @beta
    queryClient?: QueryClient;
    sdkOptions?: SDKOptions;
    storageInterface?: IStorage;
    supportedChains?: TSupportedChain[];
    // Warning: (ae-incompatible-release-tags) The symbol "walletConnectors" is marked as @public, but its signature references "WalletConnector" which is marked as @internal
    walletConnectors?: WalletConnector[];
}

// @beta
export const ThirdwebSDKProvider: React_2.FC<React_2.PropsWithChildren<ThirdwebSDKProviderProps>>;

// @public (undocumented)
export interface ThirdwebSDKProviderProps extends Omit<ThirdwebSDKProviderWagmiWrapper, "queryClient"> {
    // (undocumented)
    queryClient?: QueryClient;
}

// @public (undocumented)
export interface ThirdwebSDKProviderWagmiWrapper extends Pick<ThirdwebProviderProps, "desiredChainId" | "sdkOptions" | "storageInterface" | "authConfig"> {
    // (undocumented)
    provider: ChainOrRpc | SignerOrProvider;
    // (undocumented)
    queryClient?: QueryClient;
    // (undocumented)
    signer?: Signer;
}

// @beta
export type TokenBurnParams = {
    amount: Amount;
};

// @beta
export type TokenParams = {
    to: WalletAddress;
    amount: Amount;
};

// @beta
export type TransferNFTParams<TContract> = TContract extends Erc1155 ? {
    to: WalletAddress;
    tokenId: BigNumberish;
    amount: Amount;
} : {
    to: WalletAddress;
    tokenId: BigNumberish;
};

export { useAccount }

// Warning: (ae-internal-missing-underscore) The name "useActiveChainId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useActiveChainId(): SUPPORTED_CHAIN_ID | undefined;

// Warning: (ae-forgotten-export) The symbol "ClaimConditionsInputParams" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
//
// @beta
export function useActiveClaimCondition<TContract extends NFTContract | Erc20>(...[contract, tokenId]: ClaimConditionsInputParams<TContract>): UseQueryResult<    {
snapshot?: {
address: string;
maxClaimable: string;
}[] | undefined;
quantityLimitPerTransaction: string;
startTime: Date;
price: BigNumber;
currencyAddress: string;
maxQuantity: string;
waitInSeconds: BigNumber;
merkleRootHash: string | number[];
availableSupply: string;
currentMintSupply: string;
currencyMetadata: {
symbol: string;
value: BigNumber;
name: string;
decimals: number;
displayValue: string;
};
}, unknown>;

// @beta
export function useActiveListings(contract: RequiredParam<Marketplace>, filter?: MarketplaceFilter): UseQueryResult<(AuctionListing | DirectListing)[], unknown>;

// @public
export function useAddress(): string | undefined;

// @beta
export function useAirdropNFT(contract: Erc1155): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, AirdropNFTParams, unknown>;

// @beta
export function useAllContractEvents(contract: RequiredParam<ReturnType<typeof useContract>["contract"]>, options?: {
    queryFilter?: EventQueryFilter;
    subscribe?: boolean;
}): UseQueryResult<ContractEvent[], unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useAllRoleMembers" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "useAllRoleMembers" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
//
// @beta
export function useAllRoleMembers<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>): UseQueryResult<Awaited<Record<RolesForContract<TContract>, string[]>>, unknown>;

// @beta
export function useAuctionWinner(contract: RequiredParam<Marketplace>, listingId: RequiredParam<BigNumberish>): UseQueryResult<string | undefined, unknown>;

// Warning: (ae-internal-missing-underscore) The name "useAuth" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useAuth(loginConfig?: LoginConfig): {
    login: (cfg?: {
        chainId?: number | undefined;
        nonce?: string | undefined;
        expirationTime?: Date | undefined;
    } | undefined) => Promise<void>;
    logout: () => void;
    user: ThirdwebAuthUser | undefined;
    isLoading: boolean;
};

// @beta
export function useBalance(tokenAddress?: ContractAddress): UseQueryResult<    {
symbol: string;
value: BigNumber;
name: string;
decimals: number;
displayValue: string;
} | undefined, unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useBatchesToReveal" is marked as @public, but its signature references "NFTContract" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "useBatchesToReveal" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
//
// @public (undocumented)
export function useBatchesToReveal<TContract extends NFTContract>(contract: RequiredParam<TContract>): UseQueryResult<BatchToReveal[], unknown>;

// @beta
export function useBidBuffer(contract: RequiredParam<Marketplace>): UseQueryResult<BigNumber, unknown>;

// Warning: (ae-internal-missing-underscore) The name "useBuiltinContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useBuiltinContract<TContractType extends ContractType>(contractType?: TContractType, contractAddress?: string): ContractForContractType<TContractType> | undefined;

// @beta
export function useBurnNFT<TContract extends NFTContract>(contract: RequiredParam<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, BurnNFTParams<TContract>, unknown>;

// @beta
export function useBurnToken(contract: RequiredParam<Erc20>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, TokenBurnParams, unknown>;

// @beta
export function useBuyNow(contract: RequiredParam<Marketplace>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, {
id: BigNumberish;
type: ListingType.Direct;
buyAmount: BigNumberish;
buyForWallet?: string | undefined;
} | {
id: BigNumberish;
type: ListingType.Auction;
}, unknown>;

// @public
export function useChainId(): number | undefined;

// @beta
export function useClaimConditions<TContract extends NFTContract | Erc20>(...[contract, tokenId]: ClaimConditionsInputParams<TContract>): UseQueryResult<    {
snapshot?: {
address: string;
maxClaimable: string;
}[] | undefined;
quantityLimitPerTransaction: string;
startTime: Date;
price: BigNumber;
currencyAddress: string;
maxQuantity: string;
waitInSeconds: BigNumber;
merkleRootHash: string | number[];
availableSupply: string;
currentMintSupply: string;
currencyMetadata: {
symbol: string;
value: BigNumber;
name: string;
decimals: number;
displayValue: string;
};
}[], unknown>;

// @beta
export function useClaimedNFTs(contract: RequiredParam<DropContract>, queryParams?: QueryAllParams): UseQueryResult<NFT<DropContract>[], unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useClaimedNFTSupply" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "useClaimedNFTSupply" is marked as @public, but its signature references "DropContract" which is marked as @beta
//
// @public (undocumented)
export function useClaimedNFTSupply(contract: RequiredParam<DropContract>): UseQueryResult<BigNumber, unknown>;

// Warning: (ae-forgotten-export) The symbol "ClaimIneligibilityInputParams" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
//
// @beta
export function useClaimIneligibilityReasons<TContract extends NFTContract | Erc20>(...[contract, params, tokenId]: ClaimIneligibilityInputParams<TContract>): UseQueryResult<ClaimEligibility[], unknown>;

// @beta
export function useClaimNFT<TContract extends DropContract>(contract: RequiredParam<TContract>): UseMutationResult<ClaimNFTReturnType<TContract>, unknown, ClaimNFTParams<TContract>, unknown>;

// @beta
export function useClaimToken<TContract extends TokenDrop>(contract: RequiredParam<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, ClaimTokenParams, unknown>;

// @public
export function useCoinbaseWallet(): () => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// Warning: (ae-internal-missing-underscore) The name "useConnect" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function useConnect(): readonly [{
    readonly data: {
        readonly connected: boolean;
        readonly connector: Connector<any, any> | undefined;
        readonly connectors: Connector<any, any>[];
    };
    readonly error: Error | undefined;
    readonly loading: boolean | undefined;
}, (connector: Connector<any, any>) => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>];

// Warning: (ae-incompatible-release-tags) The symbol "useContract" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "useContract" is marked as @public, but its signature references "ContractAddress" which is marked as @beta
//
// @public
export function useContract(contractAddress: RequiredParam<ContractAddress>): {
    contract: null;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: null;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: SmartContract<BaseContract> | null;
    data: {
        contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
        compilerMetadata: null;
    } | {
        contractType: "custom";
        compilerMetadata: {
            name: string;
            metadata: Record<string, any>;
            abi: {
                [x: string]: any;
                type: string;
                name: string;
                outputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
                inputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
            }[];
            info: {
                title?: string | undefined;
                author?: string | undefined;
                details?: string | undefined;
                notice?: string | undefined;
            };
            licenses: string[];
        } | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    contract: SmartContract<BaseContract> | null;
    data: {
        contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
        compilerMetadata: null;
    } | {
        contractType: "custom";
        compilerMetadata: {
            name: string;
            metadata: Record<string, any>;
            abi: {
                [x: string]: any;
                type: string;
                name: string;
                outputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
                inputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
            }[];
            info: {
                title?: string | undefined;
                author?: string | undefined;
                details?: string | undefined;
                notice?: string | undefined;
            };
            licenses: string[];
        } | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
};

// Warning: (ae-internal-missing-underscore) The name "useContractAbi" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useContractAbi(contractAddress: RequiredParam<ContractAddress>): {
    abi: null;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    abi: null;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    abi: {
        [x: string]: any;
        type: string;
        name: string;
        outputs: {
            [x: string]: any;
            components?: {
                [x: string]: any;
                type: string;
                name: string;
            }[] | undefined;
            stateMutability?: string | undefined;
            type: string;
            name: string;
        }[];
        inputs: {
            [x: string]: any;
            components?: {
                [x: string]: any;
                type: string;
                name: string;
            }[] | undefined;
            stateMutability?: string | undefined;
            type: string;
            name: string;
        }[];
    }[] | null;
    data: {
        contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
        compilerMetadata: null;
    } | {
        contractType: "custom";
        compilerMetadata: {
            name: string;
            metadata: Record<string, any>;
            abi: {
                [x: string]: any;
                type: string;
                name: string;
                outputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
                inputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
            }[];
            info: {
                title?: string | undefined;
                author?: string | undefined;
                details?: string | undefined;
                notice?: string | undefined;
            };
            licenses: string[];
        } | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
} | {
    abi: {
        [x: string]: any;
        type: string;
        name: string;
        outputs: {
            [x: string]: any;
            components?: {
                [x: string]: any;
                type: string;
                name: string;
            }[] | undefined;
            stateMutability?: string | undefined;
            type: string;
            name: string;
        }[];
        inputs: {
            [x: string]: any;
            components?: {
                [x: string]: any;
                type: string;
                name: string;
            }[] | undefined;
            stateMutability?: string | undefined;
            type: string;
            name: string;
        }[];
    }[] | null;
    data: {
        contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
        compilerMetadata: null;
    } | {
        contractType: "custom";
        compilerMetadata: {
            name: string;
            metadata: Record<string, any>;
            abi: {
                [x: string]: any;
                type: string;
                name: string;
                outputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
                inputs: {
                    [x: string]: any;
                    components?: {
                        [x: string]: any;
                        type: string;
                        name: string;
                    }[] | undefined;
                    stateMutability?: string | undefined;
                    type: string;
                    name: string;
                }[];
            }[];
            info: {
                title?: string | undefined;
                author?: string | undefined;
                details?: string | undefined;
                notice?: string | undefined;
            };
            licenses: string[];
        } | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (RefetchOptions & RefetchQueryFilters<TPageData>) | undefined) => Promise<QueryObserverResult<    {
    contractType: "split" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined;
    compilerMetadata: null;
    } | {
    contractType: "custom";
    compilerMetadata: {
    name: string;
    metadata: Record<string, any>;
    abi: {
    [x: string]: any;
    type: string;
    name: string;
    outputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    inputs: {
    [x: string]: any;
    components?: {
    [x: string]: any;
    type: string;
    name: string;
    }[] | undefined;
    stateMutability?: string | undefined;
    type: string;
    name: string;
    }[];
    }[];
    info: {
    title?: string | undefined;
    author?: string | undefined;
    details?: string | undefined;
    notice?: string | undefined;
    };
    licenses: string[];
    } | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: FetchStatus;
};

// @beta
export function useContractCall(contract: RequiredParam<ReturnType<typeof useContract>["contract"]>, functionName: RequiredParam<string>): UseMutationResult<any, unknown, unknown[] | [...unknown[], CallOverrides] | undefined, unknown>;

// @beta
export function useContractCompilerMetadata(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<    {
name: string;
metadata: Record<string, any>;
abi: {
[x: string]: any;
type: string;
name: string;
outputs: {
[x: string]: any;
components?: {
[x: string]: any;
type: string;
name: string;
}[] | undefined;
stateMutability?: string | undefined;
type: string;
name: string;
}[];
inputs: {
[x: string]: any;
components?: {
[x: string]: any;
type: string;
name: string;
}[] | undefined;
stateMutability?: string | undefined;
type: string;
name: string;
}[];
}[];
info: {
title?: string | undefined;
author?: string | undefined;
details?: string | undefined;
notice?: string | undefined;
};
licenses: string[];
} | undefined, unknown>;

// @beta
export function useContractData(contract: RequiredParam<ReturnType<typeof useContract>["contract"]>, functionName: RequiredParam<string>, ...args: unknown[] | [...unknown[], CallOverrides]): UseQueryResult<any, unknown>;

// @beta
export function useContractEvents(contract: RequiredParam<ReturnType<typeof useContract>["contract"]>, eventName: string, options?: {
    queryFilter?: EventQueryFilter;
    subscribe?: boolean;
}): UseQueryResult<ContractEvent[], unknown>;

// Warning: (ae-internal-missing-underscore) The name "useContractFunctions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useContractFunctions(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<AbiFunction[] | null, unknown>;

// @beta
export function useContractMetadata(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<    {
[x: string]: Json;
description?: string | undefined;
image?: any;
external_link?: string | undefined;
name: string;
}, unknown>;

// @beta
export function useContractType(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<"split" | "custom" | "nft-drop" | "signature-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | "multiwrap" | undefined, unknown>;

// @beta
export function useCreateAuctionListing(contract: RequiredParam<Marketplace>): UseMutationResult<TransactionResultWithId<never>, unknown, NewAuctionListing, unknown>;

// @beta
export function useCreateDirectListing(contract: RequiredParam<Marketplace>): UseMutationResult<TransactionResultWithId<never>, unknown, NewDirectListing, unknown>;

// @beta
export function useDelayedRevealLazyMint<TContract extends NFTContract>(contract: RequiredParam<TContract>, onProgress?: (progress: UploadProgressEvent) => void): UseMutationResult<TransactionResultWithId<never>[], unknown, DelayedRevealLazyMintInput, unknown>;

// Warning: (ae-internal-missing-underscore) The name "useDesiredChainId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useDesiredChainId(): number;

// @public
export function useDisconnect(options?: {
    reconnectAfterGnosis?: boolean;
}): () => Promise<void | {
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// @public
export function useEdition(contractAddress?: string): Edition | undefined;

// @public
export function useEditionDrop(contractAddress?: string): EditionDrop | undefined;

// @public
export function useGnosis(): (config: GnosisConnectorArguments) => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// Warning: (ae-incompatible-release-tags) The symbol "useGrantRole" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
//
// @beta
export function useGrantRole<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>): UseMutationResult<void, unknown, {
role: RolesForContract<TContract>;
address: WalletAddress;
}, unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useIsAddressRole" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "useIsAddressRole" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
//
// @beta
export function useIsAddressRole<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>, role: RolesForContract<TContract>, walletAddress: RequiredParam<WalletAddress>): boolean;

// @beta
export function useLazyMint<TContract extends NFTContract>(contract: RequiredParam<TContract>, onProgress?: (progress: UploadProgressEvent) => void): UseMutationResult<TransactionResultWithId<    {
[x: string]: Json;
name?: string | number | undefined;
description?: string | null | undefined;
image?: string | null | undefined;
external_url?: string | null | undefined;
animation_url?: string | null | undefined;
uri: string;
id: BigNumber;
}>[], unknown, {
metadatas: NFTMetadataInput[];
}, unknown>;

// @beta
export function useListing(contract: RequiredParam<Marketplace>, listingId: RequiredParam<BigNumberish>): UseQueryResult<AuctionListing | DirectListing, unknown>;

// @beta
export function useListings(contract: RequiredParam<Marketplace>, filter?: MarketplaceFilter): UseQueryResult<(AuctionListing | DirectListing)[], unknown>;

// @beta
export function useLogin(config?: LoginConfig): (cfg?: LoginOptions) => Promise<void>;

// @beta
export function useLogout(): () => void;

// @public
export function useMagic(): (configuration: LoginWithMagicLinkConfiguration) => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// @beta
export function useMakeBid(contract: RequiredParam<Marketplace>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, MakeBidParams, unknown>;

// @public
export function useMarketplace(contractAddress?: string): Marketplace | undefined;

// @beta
export function useMetadata(contract: RequiredParam<SmartContract | ValidContractInstance>): UseQueryResult<    {
[x: string]: Json;
description?: string | undefined;
image?: any;
external_link?: string | undefined;
name: string;
}, unknown>;

// @public
export function useMetamask(): () => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
} | {
    error: Error;
}>;

// @beta
export function useMintNFT<TContract extends NFTContract>(contract: RequiredParam<TContract>): UseMutationResult<MintNFTReturnType<TContract>, unknown, MintNFTParams<TContract>, unknown>;

// @beta
export function useMintNFTSupply(contract: Erc1155): UseMutationResult<TransactionResultWithId<    {
metadata: {
[x: string]: Json;
name?: string | number | undefined;
description?: string | null | undefined;
image?: string | null | undefined;
external_url?: string | null | undefined;
animation_url?: string | null | undefined;
uri: string;
id: BigNumber;
};
supply: BigNumber;
}>, unknown, MintNFTSupplyParams, unknown>;

// @beta
export function useMintToken(contract: RequiredParam<Erc20>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, TokenParams, unknown>;

// @public
export function useMultiwrap(contractAddress?: string): Multiwrap | undefined;

// @public
export function useNetwork(): readonly [{
    readonly data: {
        readonly chain: {
            id: number;
            unsupported: boolean | undefined;
            name?: string | undefined;
            nativeCurrency?: {
                name: string;
                symbol: string;
                decimals: 18;
            } | undefined;
            rpcUrls?: string[] | undefined;
            blockExplorers?: {
                name: string;
                url: string;
            }[] | undefined;
            testnet?: boolean | undefined;
        } | undefined;
        readonly chains: Chain[];
    };
    readonly error: Error | undefined;
    readonly loading: boolean | undefined;
}, ((chainId: number) => Promise<{
    data: undefined;
    error: SwitchChainError;
} | {
    data: Chain | undefined;
    error: undefined;
}>) | undefined];

// @public
export function useNetworkMismatch(): boolean;

// @beta
export function useNFT<TContract extends NFTContract>(contract: RequiredParam<TContract>, tokenId: RequiredParam<BigNumberish>): UseQueryResult<NFT<TContract>, unknown>;

// @beta
export function useNFTBalance<TContract extends NFTContract>(...[contract, ownerWalletAddress, tokenId]: useNFTBalanceParams<TContract>): UseQueryResult<BigNumber, unknown>;

// @beta
export type useNFTBalanceParams<TContract> = TContract extends Erc1155 ? [
contract: RequiredParam<TContract>,
ownerWalletAddress: RequiredParam<WalletAddress>,
tokenId: RequiredParam<BigNumberish>
] : [
contract: RequiredParam<TContract>,
ownerWalletAddress: RequiredParam<WalletAddress>
];

// @public
export function useNFTCollection(contractAddress?: string): NFTCollection | undefined;

// @public
export function useNFTDrop(contractAddress?: string): NFTDrop | undefined;

// @beta
export function useNFTs<TContract extends NFTContract>(contract: RequiredParam<TContract>, queryParams?: QueryAllParams): UseQueryResult<NFT<TContract>[], unknown>;

// @beta
export function useOwnedNFTs<TContract extends NFTContract>(contract: RequiredParam<TContract>, ownerWalletAddress: RequiredParam<WalletAddress>): UseQueryResult<NFT<TContract>[], unknown>;

// @public
export function usePack(contractAddress?: string): Pack | undefined;

// @beta
export function usePlatformFees(contract: RequiredParam<SmartContract | ValidContractInstance>): UseQueryResult<    {
platform_fee_basis_points: number;
platform_fee_recipient: string;
}, unknown>;

// @beta (undocumented)
export function usePrimarySaleRecipient(contract: RequiredParam<SmartContract | ValidContractInstance>): UseQueryResult<string, unknown>;

export { useProvider }

// Warning: (ae-internal-missing-underscore) The name "useReadonlySDK" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useReadonlySDK(readonlyRpcUrl: string, sdkOptions: SDKOptions, storageInterface?: IStorage): ThirdwebSDK;

// @beta
export function useResetClaimConditions<TContract extends NFTContract | Erc20>(...[contract, tokenId]: ClaimConditionsInputParams<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data"> | undefined, unknown, void, unknown>;

// @public (undocumented)
export function useResolvedMediaType(uri?: string): {
    url: string | undefined;
    mimeType: string | undefined;
};

// @beta
export function useRevealLazyMint<TContract extends NFTContract>(contract: RequiredParam<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, RevealLazyMintInput, unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useRevokeRole" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
//
// @beta
export function useRevokeRole<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>): UseMutationResult<void, unknown, {
role: RolesForContract<TContract>;
address: WalletAddress;
}, unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useRoleMembers" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "useRoleMembers" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
//
// @beta
export function useRoleMembers<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>, role: RolesForContract<TContract>): UseQueryResult<string[], unknown>;

// @beta
export function useRoyaltySettings(contract: RequiredParam<SmartContract | ValidContractInstance>): UseQueryResult<    {
seller_fee_basis_points: number;
fee_recipient: string;
}, unknown>;

// @public (undocumented)
export function useSDK(): ThirdwebSDK | undefined;

// Warning: (ae-incompatible-release-tags) The symbol "useSetAllRoleMembers" is marked as @beta, but its signature references "ContractWithRoles" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "useSetAllRoleMembers" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
//
// @beta
export function useSetAllRoleMembers<TContract extends ContractWithRoles>(contract: RequiredParam<TContract>): UseMutationResult<void, unknown, { [role in RolesForContract<TContract>]: string[]; }, unknown>;

// @beta
export function useSetClaimConditions<TContract extends NFTContract | Erc20>(...[contract, tokenId]: ClaimConditionsInputParams<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data"> | undefined, unknown, SetClaimConditionsParams, unknown>;

// @public
export function useSignatureDrop(contractAddress?: string): SignatureDrop | undefined;

// Warning: (ae-internal-missing-underscore) The name "useSigner" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function useSigner(): Signer | undefined;

// @public
export function useSplit(contractAddress?: string): Split | undefined;

// @public
export function useToken(contractAddress?: string): Token | undefined;

// @beta
export function useTokenBalance(contract: RequiredParam<Erc20>, walletAddress: RequiredParam<WalletAddress>): UseQueryResult<    {
symbol: string;
value: BigNumber;
name: string;
decimals: number;
displayValue: string;
}, unknown>;

// @public
export function useTokenDrop(contractAddress?: string): TokenDrop | undefined;

// @beta
export function useTokenSupply(contract: RequiredParam<Erc20>): UseQueryResult<    {
symbol: string;
value: BigNumber;
name: string;
decimals: number;
displayValue: string;
}, unknown>;

// @beta
export function useTotalCirculatingSupply<TContract extends NFTContract>(...[contract, tokenId]: useTotalCirculatingSupplyParams<TContract>): UseQueryResult<BigNumber, unknown>;

// @beta
export type useTotalCirculatingSupplyParams<TContract> = TContract extends Erc1155 ? [contract: RequiredParam<TContract>, tokenId: BigNumberish] : [contract: RequiredParam<TContract>];

// @beta
export function useTotalCount(contract: RequiredParam<NFTContract>): UseQueryResult<BigNumber, unknown>;

// @beta
export function useTransferBatchToken(contract: RequiredParam<Erc20>): UseMutationResult<void, unknown, TokenParams[], unknown>;

// @beta
export function useTransferNFT<TContract extends NFTContract>(contract: RequiredParam<TContract>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, TransferNFTParams<TContract>, unknown>;

// @beta
export function useTransferToken(contract: RequiredParam<Erc20>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, TokenParams, unknown>;

// @beta
export function useUnclaimedNFTs(contract: RequiredParam<NFTDrop>, queryParams?: QueryAllParams): UseQueryResult<    {
[x: string]: Json;
name?: string | number | undefined;
description?: string | null | undefined;
image?: string | null | undefined;
external_url?: string | null | undefined;
animation_url?: string | null | undefined;
uri: string;
id: BigNumber;
}[], unknown>;

// Warning: (ae-incompatible-release-tags) The symbol "useUnclaimedNFTSupply" is marked as @public, but its signature references "RequiredParam" which is marked as @beta
//
// @public (undocumented)
export function useUnclaimedNFTSupply(contract: RequiredParam<NFTDrop | SignatureDrop>): UseQueryResult<BigNumber, unknown>;

// @beta
export function useUpdateMetadata(contract: RequiredParam<SmartContract | ValidContractInstance>): UseMutationResult<    {
receipt: TransactionReceipt;
data: () => Promise<any>;
}, unknown, {
[x: string]: Json;
description?: string | undefined;
image?: any;
external_link?: string | undefined;
name: string;
}, unknown>;

// @beta
export function useUpdatePlatformFees(contract: RequiredParam<SmartContract | ValidContractInstance>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, {
platform_fee_basis_points?: number | undefined;
fee_recipient?: string | undefined;
}, unknown>;

// @beta
export function useUpdatePrimarySaleRecipient(contract: RequiredParam<SmartContract | ValidContractInstance>): UseMutationResult<Omit<{
receipt: TransactionReceipt;
data: () => Promise<unknown>;
}, "data">, unknown, string, unknown>;

// @beta
export function useUpdateRoyaltySettings(contract: RequiredParam<SmartContract | ValidContractInstance>): UseMutationResult<    {
receipt: TransactionReceipt;
data: () => Promise<{
seller_fee_basis_points: number;
fee_recipient: string;
}>;
}, unknown, {
seller_fee_basis_points?: number | undefined;
fee_recipient?: string | undefined;
}, unknown>;

// @beta
export function useUser(): {
    user: ThirdwebAuthUser | undefined;
    isLoading: boolean;
};

// @public
export function useVote(contractAddress?: string): Vote | undefined;

// @public
export function useWalletConnect(): () => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// Warning: (ae-internal-missing-underscore) The name "useWalletLink" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function useWalletLink(): () => Promise<{
    data?: ConnectorData<any> | undefined;
    error?: Error | undefined;
}>;

// @beta
export function useWinningBid(contract: RequiredParam<Marketplace>, listingId: RequiredParam<BigNumberish>): UseQueryResult<Offer | undefined, unknown>;

// @beta
export type WalletAddress = string;

// Warning: (ae-internal-missing-underscore) The name "WalletConnectConnectorType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WalletConnectConnectorType = "walletConnect" | {
    name: "walletConnect";
    options: WalletConnectConnector["options"];
};

// Warning: (ae-internal-missing-underscore) The name "WalletConnector" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WalletConnector = InjectedConnectorType | WalletConnectConnectorType | WalletLinkConnectorType | MagicConnectorType | GnosisConnectorType;

// Warning: (ae-internal-missing-underscore) The name "WalletLinkConnectorType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WalletLinkConnectorType = "walletLink" | "coinbase" | {
    name: "walletLink" | "coinbase";
    options: CoinbaseWalletConnector["options"];
};

// Warning: (ae-forgotten-export) The symbol "ExecutableFn" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// Warning: (ae-forgotten-export) The symbol "Web3ButtonProps" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
//
// @beta
export const Web3Button: <TExecutableFn extends ExecutableFn>({ contractAddress, overrides, onSuccess, onError, onSubmit, isDisabled, children, functionName, params, callable, ...themeProps }: PropsWithChildren<Web3ButtonProps<TExecutableFn>>) => JSX.Element;

// Warnings were encountered during analysis:
//
// dist/declarations/dist/Provider.d.ts:39:5 - (ae-forgotten-export) The symbol "MagicConnectorArguments" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// dist/declarations/dist/Provider.d.ts:46:5 - (ae-forgotten-export) The symbol "GnosisConnectorArguments" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// dist/declarations/dist/hooks/async/roles.d.ts:126:5 - (ae-incompatible-release-tags) The symbol "role" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
// dist/declarations/dist/hooks/async/roles.d.ts:161:5 - (ae-incompatible-release-tags) The symbol "role" is marked as @beta, but its signature references "RolesForContract" which is marked as @internal
// dist/declarations/dist/hooks/useNetwork.d.ts:48:5 - (ae-forgotten-export) The symbol "SwitchChainError" needs to be exported by the entry point thirdweb-dev-react.cjs.d.ts
// dist/declarations/dist/types.d.ts:215:5 - (ae-incompatible-release-tags) The symbol "buyForWallet" is marked as @public, but its signature references "WalletAddress" which is marked as @beta
// dist/declarations/dist/types.d.ts:221:5 - (ae-incompatible-release-tags) The symbol "to" is marked as @public, but its signature references "WalletAddress" which is marked as @beta

// (No @packageDocumentation comment for this package)

```
